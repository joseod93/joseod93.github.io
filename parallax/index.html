<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Hyper Parallax</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #start-btn {
            pointer-events: auto;
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 1.2rem;
            text-transform: uppercase;
            cursor: pointer;
            letter-spacing: 4px;
            transition: 0.3s;
            box-shadow: 0 0 15px #00ffff55;
        }

        #start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffffff88;
            font-size: 0.8rem;
        }

        /* Debug video oculto pero funcional */
        video { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <button id="start-btn">INICIAR EXPERIENCIA</button>
    </div>
    <div id="status">Esperando input...</div>
    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, FaceLandmarker } from '@mediapipe/tasks-vision';

        // --- 1. CONFIGURACIÓN ESCENA (VISUALES PRO) ---
        const scene = new THREE.Scene();
        // Niebla negra para fundir el fondo
        scene.fog = new THREE.FogExp2(0x000000, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // False porque el PostProcessing se encarga
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- OBJETOS ---
        
        // 1.1 El Núcleo (Torus Knot)
        const geometry = new THREE.TorusKnotGeometry(1.5, 0.4, 128, 32);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            roughness: 0.1,
            metalness: 0.9,
            emissive: 0xaa00ff, // Brillo púrpura
            emissiveIntensity: 0.2,
            wireframe: true
        });
        const nucleus = new THREE.Mesh(geometry, material);
        scene.add(nucleus);

        // 1.2 Anillos de Túnel (Profundidad)
        const ringsGroup = new THREE.Group();
        const ringGeo = new THREE.TorusGeometry(3, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        
        for(let i=0; i<10; i++) {
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.z = -i * 2;
            ring.scale.set(1 + i*0.2, 1 + i*0.2, 1);
            ringsGroup.add(ring);
        }
        scene.add(ringsGroup);

        // 1.3 Partículas flotantes
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 700;
        const posArray = new Float32Array(particlesCount * 3);
        for(let i=0; i<particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 30; // Dispersión
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff });
        const particleMesh = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleMesh);

        // --- POST-PROCESADO (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0; // Intensidad del brillo
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 2. LÓGICA DE INPUT (GIROSCOPIO Y CÁMARA) ---
        
        let targetX = 0, targetY = 0;
        let currentX = 0, currentY = 0;
        let inputMode = "mouse"; // mouse, gyro, face
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');

        // Variables Face Tracking
        let faceLandmarker;
        let video = document.getElementById('webcam');
        let lastVideoTime = -1;

        startBtn.addEventListener('click', async () => {
            startBtn.style.display = 'none';
            statusDiv.innerText = "Iniciando sensores...";
            
            // A. Intentar iniciar Giroscopio (Móvil)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        window.addEventListener('deviceorientation', handleGyro);
                        inputMode = "gyro";
                        statusDiv.innerText = "Modo: Giroscopio (iOS)";
                    }
                } catch (e) { console.error(e); }
            } else if (window.DeviceOrientationEvent && 'ontouchstart' in window) {
                // Android / iOS antiguo (si es touch device)
                window.addEventListener('deviceorientation', handleGyro);
                inputMode = "gyro";
                statusDiv.innerText = "Modo: Giroscopio (Android/Legacy)";
            }

            // B. Si no es móvil, iniciar Webcam
            if (inputMode !== "gyro") {
                statusDiv.innerText = "Modo: Cargando IA Facial...";
                await initFaceTracking();
            }
        });

        // Handler Giroscopio
        function handleGyro(event) {
            // Beta: Inclinación frontal (-180 a 180) -> Eje Y
            // Gamma: Inclinación lateral (-90 a 90) -> Eje X
            
            let x = event.gamma; // -90 (izq) a 90 (der)
            let y = event.beta;  // -180 a 180
            
            // Limitamos para que no de la vuelta completa
            if (x > 45) x = 45; if (x < -45) x = -45;
            if (y > 45) y = 45; if (y < -45) y = -45;

            // Mapear a coordenadas de cámara (Invertimos para efecto ventana)
            targetX = x * 0.1; 
            targetY = (y - 30) * 0.1; // Restamos 30 porque solemos sostener el móvil inclinado
        }

        // Setup Face Tracking
        async function initFaceTracking() {
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    inputMode = "face";
                    statusDiv.innerText = "Modo: Rastreo Facial Activo";
                    predictWebcam();
                });
            } catch (err) {
                statusDiv.innerText = "Modo: Mouse (Cámara/Giroscopio no disponibles)";
                window.addEventListener('mousemove', handleMouse);
            }
        }

        function predictWebcam() {
            if (inputMode === "face") {
                let startTimeMs = performance.now();
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    const result = faceLandmarker.detectForVideo(video, startTimeMs);
                    if (result.faceLandmarks.length > 0) {
                        const nose = result.faceLandmarks[0][1];
                        // Convertir 0-1 a coordenadas cámara
                        // Multiplicador 8 para mayor movimiento
                        targetX = (1 - nose.x - 0.5) * 8; 
                        targetY = (1 - nose.y - 0.5) * -8;
                    }
                }
                requestAnimationFrame(predictWebcam);
            }
        }

        // Fallback Mouse
        function handleMouse(e) {
            targetX = (e.clientX / window.innerWidth - 0.5) * 5;
            targetY = -(e.clientY / window.innerHeight - 0.5) * 5;
        }

        // --- 3. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // A. Lerp de Cámara (Suavizado de movimiento)
            currentX += (targetX - currentX) * 0.05;
            currentY += (targetY - currentY) * 0.05;
            camera.position.x = currentX;
            camera.position.y = currentY;
            camera.lookAt(0, 0, 0);

            // B. Animación de objetos
            // El núcleo gira sobre sí mismo
            nucleus.rotation.x = elapsedTime * 0.5;
            nucleus.rotation.y = elapsedTime * 0.3;

            // Los anillos pulsan
            ringsGroup.children.forEach((ring, i) => {
                ring.rotation.z += 0.005 * (i % 2 === 0 ? 1 : -1);
                // Efecto túnel infinito moviendo anillos
                ring.position.z += 0.02;
                if(ring.position.z > 2) ring.position.z = -18;
            });

            // Partículas giran suavemente
            particleMesh.rotation.y = elapsedTime * 0.05;

            // Render con Bloom
            composer.render();
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>